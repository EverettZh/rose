<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Rose • Serpentine Draw with Message</title>
<style>
  html,body{margin:0;height:100%;background:#111;display:grid;place-items:center;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{position:relative;width:min(100vw,700px);height:min(100vh,1200px)}
  canvas{position:absolute;inset:0;width:100%;height:100%;image-rendering:crisp-edges;image-rendering:-webkit-optimize-contrast}
  .ui{position:absolute;left:12px;bottom:12px;right:12px;display:flex;gap:10px;align-items:center;justify-content:space-between;color:#fff;opacity:.9}
  .btn{background:#fff;color:#111;border:0;border-radius:999px;padding:10px 14px;font-weight:600;cursor:pointer}
  .range{flex:1;margin:0 8px}
  .hint{position:absolute;top:10px;left:12px;color:#fff;opacity:.7;font-size:14px}
</style>
</head>
<body>
<div class="wrap">
  <canvas id="stage"></canvas>
  <div class="hint">Tap to pause / resume • ↻ to restart</div>
  <div class="ui">
    <button id="restart" class="btn">↻ Restart</button>
    <input id="speed" class="range" type="range" min="0.5" max="3" step="0.05" value="1.0" />
    <span id="pct">0%</span>
  </div>
</div>

<script>
/* ---------------------------------------------
   SET YOUR IMAGE SOURCE HERE:
   - URL:  const IMG_SRC = "rose.png";
   - or a data URL: "data:image/png;base64,...."
----------------------------------------------*/
const IMG_SRC = "rose.png";  // <-- change this

const DPR = Math.max(1, window.devicePixelRatio || 1);
const stage = document.getElementById('stage');
const ctx = stage.getContext('2d');

let W=0, H=0;
const mask = document.createElement('canvas');
const mctx = mask.getContext('2d');

const rose = new Image();
rose.src = IMG_SRC;
rose.onload = () => init();

let running = true;
let speedScale = 1.0;

// serpentine sweep state
let rowY = 0;      // current row top (device px)
let dir = 1;       // +1 L→R, -1 R→L
let xPos = 0;      // current x within row
let brushH = 24;   // stripe height
let brushW = 28;   // stripe width per step
let drawRect = null; // {x,y,w,h} image placement
let totalRows = 0;

// message (soft pastel pink)
const MESSAGE = "Happy 100 days with this nerd Mei!";
const PINK = "#ff8fcf";

function drawMessage() {
  const base = Math.max(W, H);
  const fontPx = Math.round(Math.max(28, base * 0.035));
  ctx.save();
  ctx.textAlign = "center";
  ctx.textBaseline = "top";
  ctx.font = `700 ${fontPx}px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif`;
  ctx.shadowColor = "rgba(0,0,0,0.45)";
  ctx.shadowBlur = Math.round(6*DPR);
  ctx.shadowOffsetY = Math.round(2*DPR);
  ctx.fillStyle = PINK;
  // place above the image with safe margin
  const yTop = Math.max(drawRect.y - Math.round(24*DPR), Math.round(12*DPR));
  ctx.fillText(MESSAGE, W/2, yTop);
  ctx.restore();
}

function init() {
  // size canvases
  const rect = stage.parentElement.getBoundingClientRect();
  W = Math.round(rect.width * DPR);
  H = Math.round(rect.height * DPR);
  stage.width = W; stage.height = H;
  mask.width = W; mask.height = H;
  ctx.setTransform(1,0,0,1,0,0);
  mctx.setTransform(1,0,0,1,0,0);
  ctx.imageSmoothingEnabled = true;
  mctx.imageSmoothingEnabled = true;

  // fit rose with extra top margin (for text) and bottom margin (avoid cut-off)
  const aspect = rose.width / rose.height;
  let drawW = Math.min(W, rose.width * DPR);
  let drawH = drawW / aspect;
  if (drawH > H * 0.82) {              // don't exceed ~82% height to leave margins
    drawH = H * 0.82;
    drawW = drawH * aspect;
  }
  const ox = (W - drawW)/2;
  const oy = Math.round(H * 0.15);     // lower image a bit so text fits above
  drawRect = { x: ox, y: oy, w: drawW, h: drawH };

  // reset mask + sweep
  mctx.clearRect(0,0,W,H);
  mctx.globalCompositeOperation = 'source-over';
  mctx.fillStyle = 'rgba(255,255,255,0.98)';

  brushH = Math.max(16, Math.round(drawH/55));
  brushW = Math.max(16, Math.round(drawW/95));

  // start *above* the text so the message is revealed too
  rowY = Math.round(drawRect.y - brushH*3);
  dir = 1;
  xPos = drawRect.x;
  totalRows = Math.ceil((drawRect.h + brushH*4) / brushH);

  running = true;
  lastTime = performance.now();
  requestAnimationFrame(tick);
}

let lastTime = 0;
function tick(now) {
  if (!running) return;
  const dt = Math.min(32, now - lastTime);
  lastTime = now;

  // draw message + image (both will be revealed by the mask)
  ctx.clearRect(0,0,W,H);
  drawMessage();
  ctx.drawImage(rose, drawRect.x, drawRect.y, drawRect.w, drawRect.h);

  // advance brush (serpentine sweep)
  const pxPerMs = 0.7 * brushW * speedScale;
  const step = Math.max(1, Math.floor(pxPerMs * dt));
  if (dir > 0) { // L → R
    const maxX = drawRect.x + drawRect.w;
    const seg = Math.min(step, maxX - xPos);
    if (seg > 0) {
      mctx.fillRect(xPos, rowY, seg, brushH);
      xPos += seg;
    } else {
      dir = -1; rowY += brushH; xPos = drawRect.x + drawRect.w;
    }
  } else {       // R → L
    const minX = drawRect.x;
    const seg = Math.min(step, xPos - minX);
    if (seg > 0) {
      mctx.fillRect(xPos - seg, rowY, seg, brushH);
      xPos -= seg;
    } else {
      dir = +1; rowY += brushH; xPos = drawRect.x;
    }
  }

  // reveal via mask
  ctx.save();
  ctx.globalCompositeOperation = 'destination-in';
  ctx.drawImage(mask, 0, 0);
  ctx.restore();

  // progress
  const swept = rowY - (drawRect.y - brushH*3);
  const total = drawRect.h + brushH*4;
  const pct = Math.max(0, Math.min(1, swept / total));
  document.getElementById('pct').textContent = Math.floor(pct*100) + '%';

  // ensure full reveal at end
  if (rowY >= drawRect.y + drawRect.h + brushH*3) {
    mctx.clearRect(0,0,W,H);
    mctx.fillStyle = 'rgba(255,255,255,1)';
    mctx.fillRect(0, 0, W, H);
    document.getElementById('pct').textContent = '100%';
    running = false;
  } else {
    requestAnimationFrame(tick);
  }
}

// UI
document.getElementById('restart').addEventListener('click', ()=>init());
document.getElementById('speed').addEventListener('input', e => { speedScale = parseFloat(e.target.value); });
stage.addEventListener('click', ()=> { running = !running; if (running) { lastTime = performance.now(); requestAnimationFrame(tick); } });
</script>
</body>
</html>
