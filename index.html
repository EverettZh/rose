# Create an HTML file that reveals the rose with a serpentine (back-and-forth) sweep
# from top to bottom, ensuring the full image is revealed at the end.

import base64

# Load final rose image and embed as base64
img_path = "/mnt/data/final_rose_with_leaves_red_front.png"
with open(img_path, "rb") as f:
    b64 = base64.b64encode(f.read()).decode("ascii")

html = """<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Rose • Serpentine Draw (Top-to-Bottom)</title>
<style>
  html,body{margin:0;height:100%;background:#111;display:grid;place-items:center;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .wrap{position:relative;width:min(100vw,700px);height:min(100vh,1200px)}
  canvas{position:absolute;inset:0;width:100%;height:100%;image-rendering:crisp-edges;image-rendering:-webkit-optimize-contrast}
  .ui{position:absolute;left:12px;bottom:12px;right:12px;display:flex;gap:10px;align-items:center;justify-content:space-between;color:#fff;opacity:.9}
  .btn{background:#fff;color:#111;border:0;border-radius:999px;padding:10px 14px;font-weight:600;cursor:pointer}
  .range{flex:1;margin:0 8px}
  .hint{position:absolute;top:10px;left:12px;color:#fff;opacity:.7;font-size:14px}
</style>
</head>
<body>
<div class="wrap">
  <canvas id="stage"></canvas>
  <div class="hint">Tap to pause / resume • ↻ to restart</div>
  <div class="ui">
    <button id="restart" class="btn">↻ Restart</button>
    <input id="speed" class="range" type="range" min="0.5" max="3" step="0.05" value="1.0" />
    <span id="pct">0%</span>
  </div>
</div>

<script>
const IMG_SRC = "data:image/png;base64,<<B64>>";
const DPR = Math.max(1, window.devicePixelRatio || 1);

const stage = document.getElementById('stage');
const ctx = stage.getContext('2d');
let W=0, H=0;

const mask = document.createElement('canvas');
const mctx = mask.getContext('2d');

const rose = new Image();
rose.src = IMG_SRC;
rose.onload = () => init();

let running = true;
let speedScale = 1.0;
let rowY = 0;          // current top of the brush row (in device px)
let dir = 1;           // +1 left->right, -1 right->left
let xPos = 0;          // current x within row
let brushH = 24;       // brush stripe height
let brushW = 28;       // brush width / step
let drawRect = null;   // target image placement
let totalRows = 0;

function init() {
  // sizing
  const rect = stage.parentElement.getBoundingClientRect();
  W = Math.round(rect.width * DPR);
  H = Math.round(rect.height * DPR);
  stage.width = W; stage.height = H;
  mask.width = W; mask.height = H;
  ctx.setTransform(1,0,0,1,0,0);
  mctx.setTransform(1,0,0,1,0,0);
  ctx.imageSmoothingEnabled = true;
  mctx.imageSmoothingEnabled = true;

  // fit rose image
  const aspect = rose.width/rose.height;
  let drawW = Math.min(W, rose.width * DPR);
  let drawH = drawW / aspect;
  if (drawH > H) { drawH = H; drawW = drawH * aspect; }
  const ox = (W - drawW)/2;
  const oy = Math.round(H*0.05);
  drawRect = {x:ox, y:oy, w:drawW, h:drawH};

  // reset animation
  mctx.clearRect(0,0,W,H);
  mctx.globalCompositeOperation = 'source-over';
  mctx.fillStyle = 'rgba(255,255,255,0.98)';
  brushH = Math.max(16, Math.round(drawH/50));
  brushW = Math.max(16, Math.round(drawW/90));
  rowY = drawRect.y;
  dir = 1;
  xPos = drawRect.x;
  totalRows = Math.ceil(drawH / brushH);
  running = true;
  lastTime = performance.now();
  requestAnimationFrame(tick);
}

let lastTime = 0;
function tick(now) {
  if (!running) return;
  const dt = Math.min(32, now - lastTime);
  lastTime = now;

  // draw rose
  ctx.clearRect(0,0,W,H);
  ctx.drawImage(rose, drawRect.x, drawRect.y, drawRect.w, drawRect.h);

  // advance brush
  const pxPerMs = 0.7 * brushW * speedScale;
  const step = Math.max(1, Math.floor(pxPerMs * dt));
  if (dir > 0) { // left -> right
    const maxX = drawRect.x + drawRect.w;
    const drawWseg = Math.min(step, maxX - xPos);
    if (drawWseg > 0) {
      mctx.fillRect(xPos, rowY, drawWseg, brushH);
      xPos += drawWseg;
    } else {
      // next row
      dir = -1;
      rowY += brushH;
      xPos = drawRect.x + drawRect.w;
    }
  } else { // right -> left
    const minX = drawRect.x;
    const drawWseg = Math.min(step, xPos - minX);
    if (drawWseg > 0) {
      mctx.fillRect(xPos - drawWseg, rowY, drawWseg, brushH);
      xPos -= drawWseg;
    } else {
      // next row
      dir = +1;
      rowY += brushH;
      xPos = drawRect.x;
    }
  }

  // composite: show only revealed part
  ctx.save();
  ctx.globalCompositeOperation = 'destination-in';
  ctx.drawImage(mask, 0, 0);
  ctx.restore();

  // progress percentage
  const rowIdx = Math.floor((rowY - drawRect.y) / brushH);
  const fracRows = Math.min(totalRows, rowIdx + (dir>0 ? (xPos - drawRect.x)/drawRect.w : (drawRect.x + drawRect.w - xPos)/drawRect.w));
  const pct = Math.max(0, Math.min(1, fracRows / totalRows));
  document.getElementById('pct').textContent = Math.floor(pct*100) + '%';

  // finish condition: once rowY passed past bottom, ensure full reveal
  if (rowY >= drawRect.y + drawRect.h) {
    // Reveal everything to guarantee completion
    mctx.clearRect(0,0,W,H);
    mctx.fillStyle = 'rgba(255,255,255,1)';
    mctx.fillRect(drawRect.x, drawRect.y, drawRect.w, drawRect.h);
    document.getElementById('pct').textContent = '100%';
    running = false;
  } else {
    requestAnimationFrame(tick);
  }
}

document.getElementById('restart').addEventListener('click', ()=>init());
document.getElementById('speed').addEventListener('input', (e)=>{ speedScale = parseFloat(e.target.value) });
stage.addEventListener('click', ()=>{ running = !running; if (running) { lastTime = performance.now(); requestAnimationFrame(tick); } });
</script>
</body>
</html>
"""

html = html.replace("<<B64>>", b64)
out_path = "/mnt/data/rose_draw_progress_sweep.html"
with open(out_path, "w", encoding="utf-8") as f:
    f.write(html)

out_path
